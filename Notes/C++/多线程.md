# 多线程基础

## 一个例子

`test_muti_thread.cpp`：

```c++
#include <iostream>
#include <pthread.h> // 多线程相关操作头文件，可移植众多平台。
 
using namespace std;
 
#define NUM_THREADS 5 // 线程数。
 
void* say_hello( void* args )
{
    cout << "hello..." << endl;
} // 函数返回的是函数指针，便于后面作为参数。
 
int main()
{
    pthread_t tids[NUM_THREADS]; // 线程id。
    for( int i = 0; i < NUM_THREADS; ++i )
    {
        int ret = pthread_create( &tids[i], NULL, say_hello, NULL ); 
        // 参数：创建的线程id，线程参数，线程运行函数的起始地址，运行函数的参数。
        
        if( ret != 0 ) // 创建线程成功返回0。
        {
            cout << "pthread_create error:error_code=" << ret << endl;
        }
    }
    pthread_exit( NULL ); // 等待各个线程退出后，进程才结束，否则进程强制结束，线程处于未终止的状态。
}
```

运行：

```shell
g++ -o run test_muti_thread.cpp -lpthread
```

运行结果1：

```shell
[root@artist multi_thread_test]# ./run
hello...hello...hello...hello...
hello...

```

运行结果2：

```shell
[root@artist multi_thread_test]# ./run
hello...hello...
hello...
hello...

```

注意：

1）此为c++程序，故用g++来编译生成可执行文件，并且要调用处理多线程操作相关的静态链接库文件pthread。

2）-lpthread 编译选项到位置可任意，如g++ -lpthread -o muti_thread_test_1 muti_thread_test_1.cpp

3）注意gcc和g++的区别，转到此文：[点击打开链接](http://blog.csdn.net/hitwengqi/article/details/8013754)



## 使用类中的函数

`2_test_muti_thread.cpp`：

```c++
#include <iostream>
#include <pthread.h>
 
using namespace std;
 
#define NUM_THREADS 5
 
class Hello
{
public:
    static void* say_hello( void* args )
    {
        cout << "hello..." << endl;
    }
};
 
int main()
{
    pthread_t tids[NUM_THREADS];
    for( int i = 0; i < NUM_THREADS; ++i )
    {
        int ret = pthread_create( &tids[i], NULL, Hello::say_hello, NULL );
        if( ret != 0 )
        {
            cout << "pthread_create error:error_code" << ret << endl;
        }
    }
    pthread_exit( NULL );
}
```

运行：

```shell
g++ -o run 2_test_muti_thread.cpp -lpthread
```

结果1：

```
hello...hello...
hello...
hello...
hello...

```

结果2：

```
hello...hello...hello...hello...



hello...
```

线程调用到函数在一个类中，那必须将该函数声明为静态函数函数，因为静态成员函数属于静态全局区，线程可以共享这个区域，故可以各自调用。



## 如何在线程调用函数时传入参数呢？

```c++
#include <iostream>
#include <pthread.h> //多线程相关操作头文件，可移植众多平台
 
using namespace std;
 
#define NUM_THREADS 5 //线程数
 
void* say_hello( void* args )
{
    int i = *( (int*)args ); //对传入的参数进行强制类型转换，由无类型指针转变为整形指针，再用*读取其指向到内容
    cout << "hello in " << i <<  endl;
} //函数返回的是函数指针，便于后面作为参数
 
int main()
{
    pthread_t tids[NUM_THREADS]; //线程id
    cout << "hello in main.." << endl;
    for( int i = 0; i < NUM_THREADS; ++i )
    {
        int ret = pthread_create( &tids[i], NULL, say_hello, (void*)&i ); //传入到参数必须强转为void*类型，即无类型指针，&i表示取i的地址，即指向i的指针
        cout << "Current pthread id = " << tids[i] << endl; //用tids数组打印创建的进程id信息
        if( ret != 0 ) //创建线程成功返回0
        {
            cout << "pthread_create error:error_code=" << ret << endl;
        }
    }
    pthread_exit( NULL ); //等待各个线程退出后，进程才结束，否则进程强制结束，线程处于未终止的状态
}
```

如果`pthread_create( &tids[i], NULL, say_hello, (void*)&i );`函数最后一个参数传入的不是`void*`类型，那么将报错：

```
...
muti_thread_test_3_2.cpp:20:64: error: invalid conversion from ‘void* (*)(int)’ to ‘void* (*)(void*)’ [-fpermissive]
         int ret = pthread_create( &tids[i], NULL, say_hello, i ); //传入到参数必须强转为void*类型，即无类型指针，&i表示取i的地址，即指向i的指针
...
```

结果：

```
hello in main..
Current pthread id = 139825757685504
hello in 0
Current pthread id = 139825749292800
Current pthread id = 139825740900096
Current pthread id = 139825732507392
hello in 3
Current pthread id = 139825724114688
hello in 3
hello in hello in 55
```

显然不是想要的结果。

## 参考

[c++多线程编程](https://blog.csdn.net/hitwengqi/article/details/8015646)