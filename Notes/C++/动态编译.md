# Linux下C++调用C动态库使用



## 生成动态链接库

建立一个源文件： max.c，代码如下：

```c
int max(int n1, int n2, int n3)
{
    int max_num = n1;
    max_num = max_num < n2? n2: max_num;
    max_num = max_num < n3? n3: max_num;
    return max_num;
}
```

编译生成共享库：

```shell
gcc -fPIC -shared -o libmax.so max.c
```

我们会得到libmax.so。

实际上上述过程分为编译和链接两步， -fPIC是编译选项，PIC是 Position Independent Code 的缩写，表示要生成位置无关的代码，这是动态库需要的特性； -shared是链接选项，告诉gcc生成动态库而不是可执行文件。

上述的一行命令等同于：

```shell
gcc -c -fPIC max.c
gcc -shared -o libmax.so max.o
```

查看文件：

```
[artist@artist test02]$ ls
libmax.so  max.c  max.h  max.o  test.c
```

其中 `libmax.so` 是动态链接库文件。



## 使用动态库编

建立 max.h ，输入以下代码：

```c
#ifndef __MAX_H__
#define __MAX_H__

int max(int n1, int n2, int n3);

#endif
```

建立一个使用`max`函数的test.c，代码如下：

```c
#include <stdio.h>
#include "max.h"

int main(int argc, char *argv[])
{
    int a = 10, b = -2, c = 100;
    printf("max among 10, -2 and 100 is %d.\n", max(a, b, c));
    return 0;
}
```

`gcc test.c -L. -lmax` 生成 `a.out`，其中 `-lmax` 表示要链接 `libmax.so`，`-L. `表示搜索要链接的库文件时包含当前路径。

注意，如果同一目录下同时存在同名的动态库和静态库，比如 `libmax.so` 和 `libmax.a` 都在当前路径下，
则gcc会优先链接动态库。

运行报错：

```
[artist@artist test02]$ ./a.out 
./a.out: error while loading shared libraries: libmax.so: cannot open shared object file: No such file or directory
```

找不到libmax.so，原来Linux是通过 `/etc/ld.so.cache` 文件搜寻要链接的动态库的。
而 `/etc/ld.so.cache` 是 ldconfig 程序读取 `/etc/ld.so.conf` 文件生成的。
（注意， `/etc/ld.so.conf` 中并不必包含 `/lib` 和 `/usr/lib`，`ldconfig`程序会自动搜索这两个目录）

如果我们把 `libmax.so` 所在的路径添加到 `/etc/ld.so.conf` 中，再以root权限运行 `ldconfig` 程序，更新 `/etc/ld.so.cache` ，`a.out`运行时，就可以找到 `libmax.so`。

但作为一个简单的测试例子，让我们改动系统的东西，似乎不太合适。
还有另一种简单的方法，就是为`a.out`指定 `LD_LIBRARY_PATH`。

```shell
[artist@artist test02]$ LD_LIBRARY_PATH=. ./a.out
max is 100.
```

程序就能正常运行了。`LD_LIBRARY_PATH=.` 是告诉 `a.out`，先在当前路径寻找链接的动态库。



## makefile让工作自动化

编写makefile，内容如下：

```makefile
.PHONY: build test clean

build: libmax.so

libmax.so: max.o
    gcc -o $@  -shared $<

max.o: max.c
    gcc -c -fPIC $<

test: a.out

a.out: test.c libmax.so
    gcc test.c -L. -lmax
    LD_LIBRARY_PATH=. ./a.out

clean:
    rm -f *.o *.so a.out
```

`make build ` 就会生成 `libmax.so`， `make test `就会生成 `a.out` 并执行，`make clean `会清理编译和测试结果。

