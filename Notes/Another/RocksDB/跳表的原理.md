# 跳表的原理

## 基本原理

The Log-Structured Merge-Tree（LSM-Tree）

SStable （Sorted String Table）

![](H:\StudyNote\RocksDB\img\跳表01.png)

如果要在这里面找 21 ，过程为 3→ 6 → 7 → 9 → 12 → 17 → 19 → 21 。

我们考虑从中抽出一些节点，建立一层索引作用的链表：

![](H:\StudyNote\RocksDB\img\跳表02.png)

跳表的主要思想就是这样逐渐建立索引，加速查找与插入。

一般来说，如果要做到严格 *O(logn)* ，上层结点个数应是下层结点个数的 1/2 。但是这样实现会把代码变得十分复杂，就失去了它在 OI 中使用的意义。

此外，我们在实现时，一般在插入时就确定数值的层数，而且层数不能简单的用随机数，而是以1/2的概率增加层数。

用实验中丢硬币的次数 K 作为元素占有的层数。显然随机变量 K 满足参数为 p = 1/2 的几何分布，K 的期望值 E[K] = 1/p = 2. 就是说，各个元素的层数，期望值是 2 层。

同时，为了防止出现极端情况，设计一个最大层数MAX_LEVEL。如果使用非指针版，定义这样一个常量会方便许多，更能节省空间。如果是指针版，可以不加限制地任由它增长。

## 跳表的插入

先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）

然后在 Level 1 ... Level K 各个层的链表都插入元素。

例子：插入 119， K = 2

![](H:\StudyNote\RocksDB\img\跳表03.jpg)

如果 K 大于链表的层数，则要添加新的层。

例子：插入 119， K = 4

![](H:\StudyNote\RocksDB\img\跳表04.jpg)

---

**参考：**

[跳表的原理及实例](https://www.cnblogs.com/lfri/p/9991925.html)

[leveldb 源码分析 —— SkipList跳表](https://blog.csdn.net/github_29614995/article/details/78403587)